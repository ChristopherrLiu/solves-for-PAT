### 题意
模拟栈，有以下三种操作：

1. `Push key`
将key入栈

2. `Pop`
栈顶元素出栈，并输出

3. `PeekMedian`
输出当前栈的中间元素，设当前栈中有$N$个元素，输出第$\lceil N / 2 \rceil$小的元素

### 思路
本题主要的难点在于如何快速的求出第$k$小的元素，我一开始想到的是快速排序的思想来求，我们知道快速排序每次排序可以将序列按基准元素$base$划分为小于$base$和大于$base$的，如果小于$base$的有$m$个，$m \le k$则到左侧去找，反之去右侧找，这个算法的时间复杂度为$O(n)$，但是最坏情况会达到$O(n^2)$，只能得到17分

继续考虑更优的方法，可以将栈中的元素分块处理，用一个数组$num$记录栈中各元素的出现次数，$blockNum$记录每个块中元素的数目，即$blockNum[i] = \sum_{j = i * M}^{(i + 1) * M - 1}num[j]$，其中$M$为块的大小，一般取$M = \sqrt n$，查找时首先遍历块确定在哪个快中，接着再遍历块内元素，均摊时间复杂度为$O(n\sqrt n)$，可以通过

另外在网上还看到了一种树状数组的做法，用树状数组维护栈中数字的出现次数，同时由于树状数组的性质，可以方便快速地求出小于某个数字的元素个数和，再结合二分查找也可通过